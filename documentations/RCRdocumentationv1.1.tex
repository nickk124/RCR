\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{indentfirst}
\usepackage{float}
\usepackage{lmodern}
\usepackage{physics}
\usepackage{gensymb}
\newcommand*\diff{\mathop{}\!\mathrm{d}}
\setlength{\parindent}{15pt}
%opening
\title{Documentation/Starter Guide for the Robust Chauvenet Outlier Rejection Algorithm}
\begin{document}	
\maketitle
\section*{Prerequisites}
\begin{enumerate}
	\item At least basic knowledge of C++ recommended.
	\item Make sure that the following files are included in your project (besides your file with \texttt{int.main()}): (available from the RCR webpage)
	\\\textbf{Source files}
	\begin{enumerate}
		\item \texttt{RCR.cpp}
		\item \texttt{NonParametric.cpp}
		\item \texttt{FunctionalForm.cpp}
		\item \texttt{MiscFunction.cpp}
	\end{enumerate}
	\textbf{Header files}
	\begin{enumerate}
		\item \texttt{RCR.h}
		\item \texttt{NonParametric.h}
		\item \texttt{FunctionalForm.h}
		\item \texttt{MiscFunction.h}
	\end{enumerate}
\end{enumerate}
\section{Single-Value RCR}
The simplest RCR algorithm to use; the basic steps for this are as follows (code example at the bottom):
\begin{enumerate}
	\item Instantiate an object of the \texttt{RCR} class. It's recommended, but optional to specify the rejection technique from the following (see figure 19 in the RCR paper) as an argument of the constructor:
	\begin{enumerate}
		\item \texttt{SS\_MEDIAN\_DL} 
		\\(symmetric uncontaminated distribution with two-sided contaminants)
		\item \texttt{LS\_MODE\_68} 
		\\(symmetric uncontaminated distribution with one-sided contaminants)
		\item \texttt{LS\_MODE\_DL}
		\\(symmetric uncontaminated distribution with a mix of the above types of contaminants)
		\item \texttt{ES\_MODE\_DL}
		\\(Mildly asymmetric uncontaminated distribution and/or very low number of data points)
	\end{enumerate}
	If no technique is specified (the constructor argument is held blank) then \texttt{LS\_MODE\_DL} will be used by default.
	\item Depending on whether you want to perform regular RCR or Bulk Rejection RCR, and/or if your data is weighted or not, call the \texttt{RCR} class method \texttt{.performRejection()} or \texttt{.performBulkRejection()} as follows: if non-weighted, the sole argument will be an \texttt{std::vector <double>} of your data points,  \texttt{y} (or whatever you'd like to name it). If weighted, the two arguments will be in order, \texttt{w} and \texttt{y}, where \texttt{w} is a vector of the weights of the \texttt{y}, in the same order as that of \texttt{y}.
	
	\par \textbf{Two basic examples:} (within \texttt{int.main()})
	\\
	\\\texttt{RCR rcr = RCR(SS\_MEDIAN\_DL);}
	\\\texttt{rcr.performBulkRejection(w, y);}
	
	or
	
	\texttt{RCR rcr = RCR();}
	\\\texttt{rcr.performRejection(y);}
\end{enumerate}
\section{Non-Parametric RCR}
The basic steps for this are as follows (code example at the bottom):
\begin{enumerate}
	\item In your \texttt{int.main()}, Instantiate an object of the \texttt{NonParametric} class.
	\item Instantiate an object of the \texttt{RCR} class. Specify the rejection technique, if wanted.
	\item Call the \texttt{RCR} class method \texttt{.setNonParametricModel()} on your \texttt{RCR} object, with your \texttt{NonParametric} object as the method's sole argument.
	\item Depending on whether you want to perform regular RCR or Bulk Rejection RCR, and/or if your data is weighted or not, call the \texttt{RCR} class method \texttt{.performRejection()} or \texttt{.performBulkRejection()}.
	
	\newpage
	\par \textbf{Two basic examples:} (within \texttt{int.main()})
	\\
	\\\texttt{NonParametric model = NonParametric();}
	\\\texttt{RCR rcr = RCR(SS\_MEDIAN\_DL);}
	\\\texttt{rcr.setNonParametricModel(model);}
	\\\texttt{rcr.performBulkRejection(w, y);}
	
	or
	
	\texttt{NonParametric model = NonParametric();}
	\\\texttt{RCR rcr = RCR();}
	\\\texttt{rcr.setNonParametricModel(model);}
	\\\texttt{rcr.performRejection(y);}
\end{enumerate}
\section{Functional Form/Parametric RCR}
The most complex RCR algorithm to use, it is fairly involved, and there are a number of things to specify. The basic steps are as follows (multiple code examples at the bottom). Following that section, there is a further explanation on how to implement the usage of prior distributions/information on the parameters.
\begin{enumerate}
	\item First, you must define your model function of the form $y = f(\vec{x},\vec{\theta}\,)$, where $\vec{x}$ is either a single independent variable $x$, or a vector of independent variables $\vec{x} = (x_1, x_2, \cdots x_i)$; $\vec{\theta}$ is a vector of the model parameters of the function (to be determined by RCR). For example, with the function $y = be^{m(x-0.5)}$, we have that $\vec{x} \equiv x$ and $\vec{\theta} = (b, m)$ (or however else you want to order the parameters). \textbf{You'll need to define your function somewhere in your codebase so that it returns a double; it'll have different arguments depending on whether $x$ is 1-dimensional, or an n-dimensional vector.} In this 1D case, your function will need to have two arguments: a double $x$ and a vector of doubles corresponding to $\vec{theta}$, the parameters (even if there is only a single parameter). An example of this, using the same function, is as follows:
	
	\texttt{double func(double x, std::vector <double> params) \{}
	\\\rule{1cm}{0cm}\texttt{double b = params[0];}
	\\\rule{1cm}{0cm}\texttt{double m = params[1];}	
	\\
	\\\rule{1cm}{0cm}\texttt{return b * std::exp(m *(x - 0.5));}
	\\\texttt{	\}}
	\newpage 
	To show the ND case, define $y = a_0 + a_1x_1 + a_2x_2$, where now, $\vec{x} = (x_1, x_2)$ and $\vec{\theta} = (a_0, a_1, a_2)$. Now, $x$ is a vector, so in the code, you'd have
	
	\texttt{double NDfunc(std::vector <double> x, std::vector <double> params) \{}
	\\\rule{1cm}{0cm}\texttt{double a0 = params[0];}
	\\\rule{1cm}{0cm}\texttt{double a1 = params[1];}
	\\\rule{1cm}{0cm}\texttt{double a2 = params[2];}
		
	\rule{1cm}{0cm}\texttt{double x1 = x[0];}
	\\\rule{1cm}{0cm}\texttt{double x2 = x[1];}
		
	\rule{1cm}{0cm}\texttt{return a0 + a1*x1 + a2*x2;}
		
	\}
	\item The second important item(s) that must be provided somewhere in your code are the partial derivatives of your aforementioned function with respect to each of the parameters (for use in the Jacobian within the modified Gauss-Newton algorithm used in the code). Using the same exponential example, you'd have that $\pdv{f}{b} = e^{m(x-0.5)}$ and $\pdv{f}{m} = (x-0.5)be^{m(x-0.5)}$. \textbf{In your code, these need to be defined as seperate functions, taking arguments and returning values in the exact same fashion as how the corresponding functions should be defined} (again dependent on whether there is $>1$ independent variables or not). As an example, the above partials could appear in the code as follows:
	
	\texttt{double partial1(double x, std::vector <double> params)}
	\{
	\\\rule{1cm}{0cm}\texttt{double b = params[0];}
	\\\rule{1cm}{0cm}\texttt{double m = params[1];}
		
	\rule{1cm}{0cm}\texttt{return std::exp(m *(x - 0.5));}
		
	\};
	
	\texttt{double partial2(double x, std::vector <double> params)}
	\\\{
	\\\rule{1cm}{0cm}\texttt{double b = params[0];}
	\\\rule{1cm}{0cm}\texttt{double m = params[1];}
		
	\rule{1cm}{0cm}\texttt{return (x-0.5) * b * std::exp(m *(x - 0.5));}
		
	\};
	
	\textbf{Be careful that the parameters are ordered the same within the parameter vectors for all of your definitons;} if they aren't consistent, the code won't work properly.
	\newpage
	\item Next, you'll need to create a vector of your partial functions. The syntax for this is a bit unusual, and will again differ on whether your $x$ is 1D, or multi-dimensional. Make sure to order the partials (corresponding to what they are differentiating with respect to) in the same order as your chosen definition for the parameter vector as used in the rest of your own code. For the 1-dimensional example, you'd have something similar to 
	
	\texttt{std::vector <double(*)(double, std::vector <double>)> partialsvector = \{ partial1, partial2 \};}
	
	and for the ND case (such as the example used above) you'd have something like
	
	\texttt{std::vector <double(*)(std::vector <double>, std::vector <double>)> NDpartialsvec = \{ NDpartial1, NDpartial2, NDpartial3 \};}
	
	\item Finally, you'll need to create two more things: 
	\begin{enumerate}
		\item A chosen \texttt{double} tolerance for the convergence of the Gauss-Newton algorithm (the lower it is, the longer the process may take, but the more precise it will be. $1e-3$ is a good, balanced number to start with.
		\item An initial guess vector for the true values of the parameters in the model parameters vector, also defined as an \texttt{std:vector <double> }. Dependent on the situation, if your guess is too far off of the true values, you may not get the algorithm to always converge, which could mess up your results, so try to determine the best guess possible.
	\end{enumerate}
	\item Next, on to the data: you'll need your \texttt{std:vector <double> } vectors of your $\vec{y}$ data, and the corresponding vector of error bars $\vec{\sigma}_y$. If there is a single independent variable $x$, the $x$ data vector will also be a \texttt{std:vector <double> }. In the ND case, your x data will instead be a vector of these vectors (\texttt{std:vector < std::vector < <double> >}. Be sure that your inner x vectors within the big vector have their data ordered in the same manner as you defined your function and your partials. Also, be sure that your $y$, $sigma_y$, $x$ and optional weights ( also a \texttt{std:vector <double> }) are in the correct order with respect to each other.
	\item Finally, you are ready to run the FunctionalForm RCR. First, instantiate an object of the \texttt{FunctionalForm} class with the following arguments if unweighted:
	
	\texttt{FunctionalForm model = FunctionalForm(func, x, y, sigma\_y, partialsvector, tolerance, guess);}
	
	or if weighted,
	
	\texttt{FunctionalForm model = FunctionalForm(func, x, y, sigma\_y, partialsvector, tolerance, guess, weights);}.
	
	\item Next, instantiate an object of the RCR class with your chosen (or non-chosen) rejection technique.
	\item Next call the method \texttt{.setParametricModel()} on your RCR object, with the argument of the method being your FunctionalForm object.
	\item Finally, perform rejection (or bulk rejection) the same as the other cases, by calling \texttt{performRejection} or \texttt{performBulkRejection} on the RCR object, either with or without weights. To summarize, here are two examples:
	
	\texttt{FunctionalForm model = FunctionalForm(func, x, y, sigma\_y, \\\rule{1cm}{0cm}partialsvector, tolerance, guess, weights);}
	\\\texttt{RCR rcr = RCR(SS\_MEDIAN\_DL);}
	\\\texttt{rcr.setParametricModel(model);}
	\\\texttt{rcr.performBulkRejection(weights, y);}
	
	or
	
	\texttt{FunctionalForm model = FunctionalForm(func, x, y, sigma\_y, \\\rule{1cm}{0cm}partialsvector, tolerance, guess);}
	\\\texttt{RCR rcr = RCR(LS\_MODE\_68);}
	\\\texttt{rcr.setParametricModel(model);}
	\\\texttt{rcr.performRejection(y);}
		
\end{enumerate}
\subsection{Using Priors}
\par If you have some prior knowledge of the distribution(s) of the function parameter(s) (before necessarily having any data), this can be implemented into functional RCR. The code has support for the following priors:
\begin{enumerate}
	\item Gaussian/Normal distributions with different standard deviations and means for some or all parameters
	\item Constraints/boundaries on some or all parameters
	\item A mix of the above two
	\item Custom priors (see below).
\end{enumerate} 
\subsubsection{Gaussian Priors}
To use priors that give some or all of the parameters Gaussian distributions, 

\par For the parameters of which you don't wish to add priors, 
\subsubsection{Constrained Priors}
examples: variance (can't be lower than 0), probability (must be [0,1])
\subsubsection{Gaussian and/or Constrained Priors}
\subsubsection{Custom Priors}
\par If you have custom priors, simply create a function that takes in a vector of parameters, and returns those parameters modified by the priors, be it some of them multiplied by zero if they are outside of their constraints, multiplied by a custom Gaussian or other distribution for each parameter, etc. For example, here is a custom prior that stipulates that
\begin{enumerate}
	\item the first parameter $a_0$ must be greater than zero
	\item the second parameter $a_1$ must be drawn from a Gaussian of $\mu = 1.0$, $\sigma = 2.0$.
	\item the third parameter $a_2$ has no prior.
\end{enumerate}
To implement this prior, you would create the following function:
\end{document}